/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: Sketchfab (https://sketchfab.com/Sketchfab)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/model-inspector-demo-press-i-128d863ab5c8467f80939cabe8b3fc34
Title: Model Inspector Demo (Press I)
*/

import React, { useRef, useState, useEffect } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame, useThree } from '@react-three/fiber'

import { a } from '@react-spring/three'

import carScene from '../assets/3d/car.glb'

const Car3D = (props) => {
    const { isRotating, setIsRotating, setCurrentState } = props
    const { nodes, materials } = useGLTF(carScene)
    const carRef = useRef()
    // const [isRotating, setIsRotating] = useState(false)
    const previousX = useRef(0)
    const previousY = useRef(0)
    const rotationSpeed = useRef(0)
    const dampingFactor = useRef(0.95)
    const [cursor, setCursor] = useState('pointer')

    const { camera, gl, viewport } = useThree()

    // useFrame((state, delta) => {
    //     if (carRef.current && !isRotating) {
    //         carRef.current.rotation.y += delta * 0.5 // Quay với tốc độ 0.5 radian mỗi giây
    //     }
    // })

    const handlePointerDown = (event) => {
        setIsRotating(true)
        setCursor('grabbing')
        const clientX = event.touches ? event.touches[0].clientX : event.clientX
        const clientY = event.touches ? event.touches[0].clientY : event.clientY
        previousX.current = clientX
        previousY.current = clientY
    }

    const handlePointerUp = (event) => {
        event.stopPropagation()
        setIsRotating(false)
        setCursor('pointer')

        const clientX = event.touches ? event.touches[0].clientX : event.clientX
        const deltaX = (clientX - previousX.current) / viewport.width
        carRef.current.rotation.y += deltaX * 0.01 * Math.PI
        previousX.current = clientX
    }

    const handlePointerMove = (event) => {
        // Chỉ xoay khi đang giữ chuột trái hoặc đang chạm (touch)
        const isMouseDown = event.buttons === 1
        const isTouch = !!event.touches

        if (!isRotating || (!isMouseDown && !isTouch)) return

        const clientX = isTouch ? event.touches[0].clientX : event.clientX
        const deltaX = clientX - previousX.current

        if (carRef.current) {
            carRef.current.rotation.y += deltaX * 0.01
        }

        previousX.current = clientX
    }

    //key
    const handleKeyDown = (event) => {
        switch (event.key) {
            case 'ArrowLeft':
                if (!isRotating) {
                    setIsRotating(true)
                }
                carRef.current.rotation.y += 0.01 * Math.PI
                break
            case 'ArrowRight':
                if (!isRotating) {
                    setIsRotating(true)
                }
                carRef.current.rotation.y -= 0.01 * Math.PI
        }
    }

    const handleKeyUp = (event) => {
        if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
            setIsRotating(false)
        }
    }

    // Hàm xác định state theo góc xoay
    const updateStateByRotation = (rotationY) => {
        // Đảm bảo rotationY luôn dương
        let angle = rotationY % (2 * Math.PI)
        if (angle < 0) angle += 2 * Math.PI

        // Chia 360 độ thành 4 phần đều nhau (mỗi phần 90 độ - π/2 radian)
        if (angle < Math.PI / 2) setCurrentState('1')
        else if (angle < Math.PI) setCurrentState('2')
        else if (angle < Math.PI * 3 / 2) setCurrentState('3')
        else setCurrentState('4')
    }

    useFrame((state, delta) => {
        if (!isRotating) {
            rotationSpeed.current *= dampingFactor.current

            if (Math.abs(rotationSpeed.current) < 0.001) {
                rotationSpeed.current = 0
            }
            carRef.current.position.x += rotationSpeed.current * delta
        }
        else {
            const rotation = carRef.current.rotation.y
            updateStateByRotation(rotation)
        }
    })

    // useEffect(() => {
    //     document.addEventListener('keydown', handleKeyDown)
    //     document.addEventListener('keyup', handleKeyUp)
    //     return () => {
    //         document.removeEventListener('keydown', handleKeyDown)
    //         document.removeEventListener('keyup', handleKeyUp)
    //     }
    // }, [])

    // useEffect(() => {

    //     document.addEventListener('pointermove', handlePointerMove)
    //     document.addEventListener('pointerdown', handlePointerDown)
    //     document.addEventListener('pointerup', handlePointerUp)
    //     document.addEventListener('keydown', handleKeyDown)
    //     document.addEventListener('keyup', handleKeyUp)
    //     return () => {
    //         document.removeEventListener('pointerdown', handlePointerDown)
    //         document.removeEventListener('pointerup', handlePointerUp)
    //         document.removeEventListener('pointerleave', handlePointerUp)
    //         document.removeEventListener('keydown', handleKeyDown)
    //         document.removeEventListener('keyup', handleKeyUp)
    //     }
    // }, [gl, handlePointerDown, handlePointerMove, handlePointerUp, handleKeyDown, handleKeyUp])

    return (
        <a.group
            ref={carRef}
            {...props}
            onPointerDown={handlePointerDown}
            onPointerMove={handlePointerMove}
            onPointerUp={handlePointerUp}
            // onPointerLeave={handlePointerUp}
            style={{ cursor: cursor }}
        >
            <group rotation={[-Math.PI / 2, 0, 0]} scale={0.004}>
                <mesh
                    geometry={nodes.Object_2.geometry}
                    material={materials.Body_SG1}
                />
                <mesh
                    geometry={nodes.Object_3.geometry}
                    material={materials.Ground_SG}
                />
                <mesh
                    geometry={nodes.Object_4.geometry}
                    material={materials.Interior_SG}
                />
                <mesh
                    geometry={nodes.Object_5.geometry}
                    material={materials.Windows_SG}
                />
            </group>
        </a.group>
    )
}

useGLTF.preload('/car.glb')
export default Car3D
